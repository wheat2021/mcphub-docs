---
title: '多仓库聚合：自定义脚本方案'
description: '当官方 multirepo action 不稳定时，使用自定义 Node 脚本在工作流内完成聚合，并避免子模块与重复 Tab 等问题'
icon: 'code-merge'
---

当官方 `mintlify/mintlify-multirepo-action` 在特定 Runner/仓库状态下出现解析或检出问题时，可以用自定义 Node 脚本在 GitHub Actions 中完成多仓库聚合。该方案具备：
- 幂等：避免重复追加 Tab，连续运行不会无限膨胀导航
- 去子模块化：把子仓内容当普通文件提交，不产生 submodule 指针
- 可扩展：可按需改为合并到现有 Tab/分组，或支持多个子仓

## 适用场景
- 希望统一门户（一个主仓库/站点）整合多个产品文档，各产品自有独立仓库
- 官方 multirepo action 在你环境中出现不稳定（例如 Unexpected end of JSON input）

## 工作流核心片段（最小可用）
下方代码在主仓库的 `docs` 分支执行聚合：
- 克隆子仓 `wheat2021/mcphub-docs@main` 到目录 `mcphub-docs`
- 删除 `mcphub-docs/.git`，确保以普通文件提交
- 将子仓 docs.json 的导航抽取为 groups，并以 `mcphub-docs/` 为前缀合入主仓导航
- 若主仓导航是 `tabs` 结构，则幂等地新增/覆盖一个名为 `mcphub-docs` 的 Tab

```yaml path=null start=null
name: Aggregate Mintlify Docs

on:
  push:
    branches: ["main"]

jobs:
  aggregate-docs:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Aggregate (custom node script)
        shell: bash
        run: |
          set -euo pipefail
          git checkout docs
          node <<'NODE'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          function sh(cmd){ console.log('$', cmd); return execSync(cmd, {stdio:'inherit'}); }
          // 基仓 docs.json
          const basePath = 'docs.json';
          const base = JSON.parse(fs.readFileSync(basePath, 'utf8'));
          // 克隆子仓到仓库内目录
          const TMP = '_subrepo_merge';
          const DEST = 'mcphub-docs';
          if (fs.existsSync(TMP)) fs.rmSync(TMP, {recursive:true, force:true});
          if (fs.existsSync(DEST)) fs.rmSync(DEST, {recursive:true, force:true});
          sh('git clone --depth 1 --branch main https://github.com/wheat2021/mcphub-docs ' + TMP);
          fs.renameSync(TMP, DEST);
          const gitDir = path.join(DEST, '.git');
          if (fs.existsSync(gitDir)) fs.rmSync(gitDir, {recursive:true, force:true});
          const sub = JSON.parse(fs.readFileSync(path.join(DEST, 'docs.json'), 'utf8'));
          // 导航合并
          const prependPrefix = (g,p)=>({ ...g, pages:(g.pages||[]).map(e=> typeof e==='string'? `${p}/${e}`: prependPrefix(e,p))});
          const extractGroups = (nav)=>{ const gs=[]; if(!nav) return gs; if(nav.groups) gs.push(...nav.groups); if(nav.pages?.length) gs.push({group:'Pages',pages:nav.pages}); if(nav.tabs){ for(const t of nav.tabs){ if(t.groups?.length) gs.push(...t.groups); if(t.pages?.length) gs.push({group:t.tab||'Pages',pages:t.pages}); } } return gs; };
          const subGroups = extractGroups(sub.navigation).map(g=> prependPrefix(g, DEST));
          if (Array.isArray(base.navigation?.tabs)){
            const label = 'mcphub-docs';
            const i = (base.navigation.tabs||[]).findIndex(t=>t.tab===label);
            const newTab = { tab: label, groups: subGroups };
            if (i>=0) base.navigation.tabs[i]=newTab; else base.navigation.tabs = [...(base.navigation.tabs||[]), newTab];
          } else {
            base.navigation.groups = [ ...(base.navigation.groups||[]), ...subGroups ];
          }
          fs.writeFileSync(basePath, JSON.stringify(base, null, 2));
          NODE
          # 清理历史 submodule 指针并提交
          git rm --cached -r mcphub-docs || true
          rm -f .gitmodules || true
          git add -A mcphub-docs docs.json
          git -c user.name="Mintie Bot" -c user.email="aws@mintlify.com" commit -m "chore: aggregate mcphub-docs" || true
          git push origin docs
```

要点说明
- 子仓内容进入主仓库 mcphub-docs/ 目录，页面路径统一使用 `mcphub-docs/...` 前缀，确保链接唯一。
- 幂等：如果 Tab `mcphub-docs` 已存在，则覆盖其 groups，避免重复追加。
- 去子模块：删除 `mcphub-docs/.git`，并在提交前执行 `git rm --cached -r mcphub-docs` 与删除 `.gitmodules`，彻底清理遗留 submodule 指针。
- 权限：
  - 聚合与推送到“当前（聚合）仓库”的 docs 分支：使用工作流自带的 `GITHUB_TOKEN`，并在工作流 `permissions` 中授予 `contents: write` 即可。
  - 跨仓触发（子仓→聚合仓）使用 `repository_dispatch`：若使用精细化 PAT，容易出现 403（`Resource not accessible by personal access token`）。建议改用“经典 PAT（classic PAT）”，至少包含 `repo` 与 `workflow` scopes；或确保精细化 PAT 的 Resource owner、仓库范围与仓库权限（至少 `Contents: write`、`Actions: write`）完全覆盖目标仓库。

## 我们的实施问题与排查记录
1) Unexpected end of JSON input
   - 现象：官方 action 在切换到 docs 分支后读取 `docs.json` 时抛错。
   - 根因/猜测：在特定 Runner/检出顺序下，工作树尚未稳定，导致读取空字符串。
   - 规避：
     - 预置/修复目标分支：首次运行前确保 docs 分支存在且包含完整 `docs.json`；并在 action 前用 Node 解析一次主仓 `docs.json`。
     - 改用自定义脚本，避免对内部 Git/HEAD 状态的依赖。

2) 重复 Tab
   - 现象：多次聚合后出现多个 `"tab": "mcphub-docs"`。
   - 解决：合并逻辑改为幂等（若已存在同名 Tab 则覆盖）。

3) 目录为空/子模块残留
   - 现象：docs 分支出现空目录或日志提示 `No url found for submodule path`。
   - 原因：早期一次运行把 `mcphub-docs` 作为 submodule 记录到了索引。
   - 解决：删除 `mcphub-docs/.git`，并执行 `git rm --cached -r mcphub-docs` 与删除 `.gitmodules` 后再 `git add -A` 提交。

4) YAML 语法问题
   - 现象：步骤名中含冒号 `:` 触发 YAML 解析错误。
   - 解决：调整步骤名（例如用 `-` 代替 `:`），或为字符串加引号。

5) PAT 权限与最小授权
   - 若需要跨私有仓读取子仓：细粒度 PAT（Fine-grained）选择目标仓库，权限至少 `Contents: Read`（子仓）与 `Contents: Write`（基仓）。
   - 如果只推送到当前仓库，可优先使用 `GITHUB_TOKEN`。

## 变体与扩展
- 多子仓：把目标仓库数组化，循环克隆并累计合并。
- 合并到现有 Tab/分组：将 `newTab` 替换为把 `subGroups` 追加到指定分组。
- 前缀别名：将 `DEST` 改为更直观的别名（如 `product-a`）。

## 验证
- 运行成功后：
  - docs 分支出现 `mcphub-docs/` 目录及内容
  - docs 分支的 `docs.json` 新增/更新 `tab: mcphub-docs`（或你的别名），其 pages 指向 `mcphub-docs/...`
- Mintlify 仪表盘把站点指向 `docs` 分支即可。

## 跨仓触发与通知工作流（子仓→聚合仓）
当子仓更新时，可通过 `repository_dispatch` 通知聚合仓执行聚合。示例（子仓工作流）：

```yaml
name: Notify aggregator to update

on:
  push:
    branches: ["main"]
    paths:
      - '**.md'
      - '**.mdx'
      - 'docs.json'
      - 'images/**'
      - 'logo/**'
      - 'snippets/**'
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger repository_dispatch in main docs repo
        env:
          GH_PAT: ${{ secrets.AGGREGATOR_PAT }}
        run: |
          set -euo pipefail
          test -n "${GH_PAT:-}" || { echo "AGGREGATOR_PAT not set" >&2; exit 1; }
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${GH_PAT}" \
            https://api.github.com/repos/wheat2021/docs/dispatches \
            -d '{"event_type":"subdocs-updated","client_payload":{"source":"mcphub-docs"}}'
```

权限与常见问题：
- 403 `Resource not accessible by personal access token`
  - 修复：将通知用的令牌切换为“经典 PAT（classic PAT）”，并赋予 `repo` + `workflow` scopes；或正确配置精细化 PAT（Resource owner 与目标仓一致，仓库范围包含目标仓，权限至少 `Contents: write`、`Actions: write`）。
  - 说明：即便账号对仓库有 admin 权限，精细化 PAT 仍可能因范围/Owner/权限不匹配而 403。

## 一致性检查（与当前工作流）
- 子仓工作流（本仓）：`.github/workflows/notify-aggregate.yml`
  - 已在 push(main) + 指定路径变更时，通过 `repository_dispatch` 通知聚合仓 `wheat2021/docs`，`event_type=subdocs-updated`。使用 secret `AGGREGATOR_PAT`（推荐 classic PAT：`repo` + `workflow`）。
- 聚合仓工作流：`/github/workflows/aggregate-docs.yml`（仓库：`wheat2021/docs`）
  - 触发条件：`push` 到 `main` + `schedule`（每日 0 点）。
  - 权限：`permissions: contents: write`，聚合和推送使用 `GITHUB_TOKEN` 即可。n  - 执行：检出、保证 `docs` 分支存在与 `docs.json` 可解析，克隆并合并 `wheat2021/mcphub-docs` 内容到 `mcphub-docs/`，幂等写回导航，清理 submodule 残留并推送。
  - 现状提示：该工作流当前未监听 `repository_dispatch`。如需“子仓更新即刻触发聚合”，可在聚合仓工作流中追加：
    ```yaml
    on:
      repository_dispatch:
        types: [subdocs-updated]
    ```
  - 另：文件中存在 `env: GH_PAT: ${{ secrets.PUSH_TOKEN }}`，但默认流程使用 `GITHUB_TOKEN` 推送，`PUSH_TOKEN` 可作为备用，不是必需。
